package elements;

import org.openqa.selenium.By;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.util.List;

import static conf.TestManager.getDriver;

// В тесті є дублювання driver.findElement. Але так як неможемо це зробити в самому PageObject, так якщо ми розмістимо там, то він зразу буде намагатись знайти елемент.class
// Тому будемо це виконувати тут
// переносити сюди драйвер не дуже, тому в TestManager створемо метод getDriver (по суті гетер, який буде повертати драйвер

// Абстракція — це принцип ООП, згідно якому при проектуванні класів та створення обєктів необхідно виділяти тільки головні сутності, та відкидати другорядні.
// Абстрактний клас — це максимально абстрактна, дуже приблизна "заготовка" для групи майбутніх класів. Цю заготовку неможна використовувати в готовому вигляді — дуже "сира". Але вона описує деякий загальний стан та поведінку, якою будуть володіти майбутні класи-наслідники абстрактного класу.
// Абстрактний клас схожий на звичайний клас. В абстрактному класі також можна визначити поля та методи, в той же час неможна створити обєкт чи екземпляр абстрактного класу. Абстрактні класи потрібні для надання базового функціоналу для класів-потомків. А похідні класи вже реалізують цей функціонал.
// Екземпляр абстрактного класу створити неможна
// Клас являється абстрактним, якщо хоча б один з його методів являється абстрактним
// Якщо метод помічений словом abstract, кожен клас-потомок повинен його реалізувати або бути оголешеним як абстрактний. Інакше компілятор видасть помилку
// Інтерфейс описує тільки поведінку, у нього немає стану. А у абстрактному класі все є
// Абстрактний клас звязує між собою та обєднує класи, які мають дуже близький звязок. В той же час, один і той самий інтерфейс можуть реалізувати класи, у яких взагалі немає нічого спільного
// Класи можуть реалізувати багато інтерфейсів, але наслідуватись можна тільки від одного класу.
public abstract class Element {
    // Модифікатори доступа - це частіше всього ключові слова, які регулюють рівень доступності до різних частин коду.
    // Поля та методи, які позначені модифікатором доступа protected, будуть видні: в межах усіх класів, які знаходяться в тому ж пакеті, що і поточний клас, або в межах всіх класів-наслідників поточного класу.
    protected By by;
    protected WebDriver driver = getDriver();

    public Element(By by){
        this.by = by;
    }

    // типи елементів: лінка, 2 поля, контейнер

    // для того щоб заховати findElement
    // цей елемент буде викликати driver findElement та буде отримувати на вхід by, який маємо в цьому елементі
    WebElement compose(){
        return driver.findElement(by);
    }

//    List composeElements(){
//        List<WebElement> elements = driver.findElements(by);
//        return elements;
//    }

    // нам потрібен метод click
    public void click(){
        compose().click();
    }

    public boolean isExist(){
        // якщо не знайде елемент, то буде ексепшн. тому обробляємо це за допомогою try catch
        try {
            compose();
            return true;
        }
        catch (NullPointerException e) {
            return false;
        }
        catch (NoSuchElementException  e) {
            return false;
        }


    }
}
